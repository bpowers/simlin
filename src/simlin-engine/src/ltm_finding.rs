// Copyright 2025 The Simlin Authors. All rights reserved.
// Use of this source code is governed by the Apache License,
// Version 2.0, that can be found in the LICENSE file.

//! Strongest-path loop discovery algorithm from Eberlein & Schoenberg (2020).
//!
//! This module implements the heuristic "loops that matter" discovery algorithm
//! described in Appendix I of "Finding the Loops That Matter" (2020). Instead of
//! exhaustively enumerating all feedback loops (which grows factorially with model
//! size), this algorithm uses a DFS guided by link score magnitudes to find the
//! most important loops at each simulation timestep.
//!
//! The algorithm runs as a post-processing step on simulation results that include
//! link score synthetic variables (generated by `with_ltm_all_links()`).

use std::collections::{HashMap, HashSet};

use crate::common::{Canonical, Ident, Result};
#[cfg(test)]
use crate::ltm::Link;
use crate::ltm::{CausalGraph, Loop, LoopPolarity};
use crate::project::Project;
use crate::results::Results;

// --- Types ---

/// A parsed link score offset: ((from_variable, to_variable), offset_in_results).
type LinkOffset = ((Ident<Canonical>, Ident<Canonical>), usize);

// --- Constants (from the paper) ---

/// Maximum loops to retain after discovery (paper uses 200)
const MAX_LOOPS: usize = 200;

/// Minimum average relative contribution to keep a loop (paper uses 0.1%)
const MIN_CONTRIBUTION: f64 = 0.001;

/// Prefix for link score synthetic variables
const LINK_SCORE_PREFIX: &str = "$⁚ltm⁚link_score⁚";

/// Separator character in LTM variable names (U+205A TWO DOT PUNCTUATION)
const LTM_SEP: char = '⁚';

// --- Internal types ---

/// An outbound edge in the search graph: target variable and |link_score|.
#[cfg_attr(feature = "debug-derive", derive(Debug))]
struct ScoredEdge {
    to: Ident<Canonical>,
    /// Absolute value of link score at this timestep
    score: f64,
}

/// The search graph for one timestep: adjacency list with edges sorted by |score| desc.
#[cfg_attr(feature = "debug-derive", derive(Debug))]
struct SearchGraph {
    /// variable -> outbound edges, sorted by |score| descending
    adj: HashMap<Ident<Canonical>, Vec<ScoredEdge>>,
    /// stock variables (search starts from each stock)
    stocks: Vec<Ident<Canonical>>,
}

// --- Public types ---

/// A loop found by the strongest-path algorithm, with its scores over time.
#[cfg_attr(feature = "debug-derive", derive(Debug))]
pub struct FoundLoop {
    /// The loop structure (reuses existing Loop type from ltm.rs)
    pub loop_info: Loop,
    /// Loop score at each timestep: (time, signed_score)
    /// The signed score is the product of the signed link scores.
    pub scores: Vec<(f64, f64)>,
    /// Average |score| over the simulation (for ranking/filtering)
    pub avg_abs_score: f64,
}

impl SearchGraph {
    /// Build from a list of (from, to, abs_score) triples.
    fn from_edges(
        edges: Vec<(Ident<Canonical>, Ident<Canonical>, f64)>,
        stocks: Vec<Ident<Canonical>>,
    ) -> Self {
        let mut adj: HashMap<Ident<Canonical>, Vec<ScoredEdge>> = HashMap::new();

        for (from, to, score) in edges {
            // Treat NaN as 0
            let score = if score.is_nan() { 0.0 } else { score };
            adj.entry(from).or_default().push(ScoredEdge { to, score });
        }

        // Sort each edge list by |score| descending
        for edges in adj.values_mut() {
            edges.sort_by(|a, b| {
                b.score
                    .abs()
                    .partial_cmp(&a.score.abs())
                    .unwrap_or(std::cmp::Ordering::Equal)
            });
        }

        SearchGraph { adj, stocks }
    }

    /// Build from simulation results at a specific timestep.
    ///
    /// Scans results.offsets for variables matching the LTM link score prefix
    /// `$⁚ltm⁚link_score⁚{from}⁚{to}`, reads values at the given step,
    /// and builds the adjacency list.
    fn from_results(
        results: &Results<f64>,
        step: usize,
        link_offsets: &[LinkOffset],
        stocks: &[Ident<Canonical>],
    ) -> Self {
        let mut edges = Vec::with_capacity(link_offsets.len());

        for ((from, to), offset) in link_offsets {
            let value = results.data[step * results.step_size + *offset];
            // Use absolute value for the search graph; NaN -> 0
            let abs_score = if value.is_nan() { 0.0 } else { value.abs() };
            edges.push((from.clone(), to.clone(), abs_score));
        }

        SearchGraph::from_edges(edges, stocks.to_vec())
    }

    /// Run the strongest-path search, returning discovered loop paths.
    ///
    /// Each returned path is a `Vec<Ident<Canonical>>` of variables forming
    /// the loop (not including the starting stock repeated at the end).
    ///
    /// Implements the algorithm from Appendix I of Eberlein & Schoenberg (2020).
    fn find_strongest_loops(&self) -> Vec<Vec<Ident<Canonical>>> {
        let mut found_loops: Vec<Vec<Ident<Canonical>>> = Vec::new();
        let mut seen_sets: HashSet<Vec<String>> = HashSet::new();

        // Initialize best_score for all variables to 0.
        // This persists across all stock iterations within a timestep.
        let mut best_score: HashMap<Ident<Canonical>, f64> = HashMap::new();
        for var in self.adj.keys() {
            best_score.insert(var.clone(), 0.0);
        }
        // Also ensure stocks are in best_score even if they have no outbound edges
        for stock in &self.stocks {
            best_score.entry(stock.clone()).or_insert(0.0);
        }

        // For each stock, set TARGET = stock and run the DFS
        for stock in &self.stocks {
            let mut visiting: HashSet<Ident<Canonical>> = HashSet::new();
            let mut stack: Vec<Ident<Canonical>> = Vec::new();

            self.check_outbound_uses(
                stock,
                1.0,
                stock,
                &mut visiting,
                &mut stack,
                &mut best_score,
                &mut found_loops,
                &mut seen_sets,
            );
        }

        found_loops
    }

    /// Recursive DFS from Appendix I of the paper.
    ///
    /// `variable`: current variable being explored
    /// `score`: accumulated path score (product of |link_scores| along the path)
    /// `target`: the stock we're trying to return to
    /// `visiting`: set of variables on the current DFS path
    /// `stack`: the current path for recording discovered loops
    /// `best_score`: highest score seen at each variable (persists across stock iterations)
    #[allow(clippy::too_many_arguments)]
    fn check_outbound_uses(
        &self,
        variable: &Ident<Canonical>,
        score: f64,
        target: &Ident<Canonical>,
        visiting: &mut HashSet<Ident<Canonical>>,
        stack: &mut Vec<Ident<Canonical>>,
        best_score: &mut HashMap<Ident<Canonical>, f64>,
        found_loops: &mut Vec<Vec<Ident<Canonical>>>,
        seen_sets: &mut HashSet<Vec<String>>,
    ) {
        // If variable.visiting is true:
        if visiting.contains(variable) {
            // If variable = TARGET: found a loop
            if variable == target {
                Self::add_loop_if_unique(stack, found_loops, seen_sets);
            }
            return;
        }

        // If score < variable.best_score: prune (strict less-than)
        let current_best = best_score.get(variable).copied().unwrap_or(0.0);
        if score < current_best {
            return;
        }

        // Set variable.best_score = score
        best_score.insert(variable.clone(), score);

        // Set variable.visiting = true, add to stack
        visiting.insert(variable.clone());
        stack.push(variable.clone());

        // For each outbound edge (already sorted by |score| desc)
        if let Some(edges) = self.adj.get(variable) {
            for edge in edges {
                self.check_outbound_uses(
                    &edge.to,
                    score * edge.score.abs(),
                    target,
                    visiting,
                    stack,
                    best_score,
                    found_loops,
                    seen_sets,
                );
            }
        }

        // Set variable.visiting = false, remove from stack
        visiting.remove(variable);
        stack.pop();
    }

    /// Add loop to results if it hasn't been seen before (deduplicate by node set).
    fn add_loop_if_unique(
        stack: &[Ident<Canonical>],
        found_loops: &mut Vec<Vec<Ident<Canonical>>>,
        seen_sets: &mut HashSet<Vec<String>>,
    ) {
        if stack.is_empty() {
            return;
        }

        // Create a sorted node set as the deduplication key
        let mut node_set: Vec<String> = stack.iter().map(|id| id.as_str().to_string()).collect();
        node_set.sort();

        if seen_sets.insert(node_set) {
            found_loops.push(stack.to_vec());
        }
    }
}

/// Parse link score variable names from results offsets.
///
/// Returns a vector of ((from, to), offset) tuples for all link score variables.
fn parse_link_offsets(results: &Results<f64>) -> Vec<LinkOffset> {
    let mut link_offsets = Vec::new();

    for (var_name, &offset) in &results.offsets {
        let name_str = var_name.as_str();
        if let Some(suffix) = name_str.strip_prefix(LINK_SCORE_PREFIX) {
            // Split on the separator to get from and to
            let parts: Vec<&str> = suffix.split(LTM_SEP).collect();
            if parts.len() == 2 {
                let from = crate::common::canonicalize(parts[0]);
                let to = crate::common::canonicalize(parts[1]);
                link_offsets.push(((from, to), offset));
            }
        }
    }

    link_offsets
}

/// Identify stock variables from the project's main model.
fn get_stock_variables(project: &Project) -> Vec<Ident<Canonical>> {
    let mut stocks = Vec::new();

    for model in project.models.values() {
        if model.implicit {
            continue;
        }
        for (var_name, var) in &model.variables {
            if matches!(var, crate::variable::Variable::Stock { .. }) {
                stocks.push(var_name.clone());
            }
        }
    }

    // Sort for deterministic ordering
    stocks.sort_by(|a, b| a.as_str().cmp(b.as_str()));
    stocks
}

/// Run the strongest-path loop discovery on simulation results.
///
/// Reads link score values from `results` (computed during simulation via
/// LTM synthetic variables), then runs the strongest-path DFS at each saved
/// timestep to discover important loops.
///
/// The project must have been augmented with `with_ltm_all_links()` before
/// simulation so that link score variables exist for all causal links.
pub fn discover_loops(results: &Results<f64>, project: &Project) -> Result<Vec<FoundLoop>> {
    let link_offsets = parse_link_offsets(results);
    if link_offsets.is_empty() {
        return Ok(Vec::new());
    }

    let stocks = get_stock_variables(project);
    if stocks.is_empty() {
        return Ok(Vec::new());
    }

    // Collect all unique loop paths across all timesteps
    let mut all_paths: Vec<Vec<Ident<Canonical>>> = Vec::new();
    let mut seen_sets: HashSet<Vec<String>> = HashSet::new();

    let step_count = results.step_count;

    // Skip step 0 where link scores are NaN (PREVIOUS values don't exist)
    for step in 1..step_count {
        let graph = SearchGraph::from_results(results, step, &link_offsets, &stocks);
        let paths = graph.find_strongest_loops();

        for path in paths {
            let mut node_set: Vec<String> = path.iter().map(|id| id.as_str().to_string()).collect();
            node_set.sort();

            if seen_sets.insert(node_set) {
                all_paths.push(path);
            }
        }
    }

    if all_paths.is_empty() {
        return Ok(Vec::new());
    }

    // Build a CausalGraph to convert paths to Loop objects
    let main_model = project
        .models
        .values()
        .find(|m| !m.implicit)
        .ok_or_else(|| crate::common::Error {
            kind: crate::common::ErrorKind::Model,
            code: crate::common::ErrorCode::NotSimulatable,
            details: Some("No non-implicit model found for loop discovery".to_string()),
        })?;
    let causal_graph = CausalGraph::from_model(main_model, project)?;

    // Convert paths to FoundLoop objects with scores
    let mut found_loops: Vec<FoundLoop> = Vec::new();

    for path in &all_paths {
        // Convert path to links using CausalGraph
        let links = causal_graph.circuit_to_links(path);
        let loop_stocks = causal_graph.find_stocks_in_loop(path);
        let polarity_structural = causal_graph.calculate_polarity(&links);

        // Compute signed loop score at each timestep
        let mut scores: Vec<(f64, f64)> = Vec::new();
        let mut abs_score_sum = 0.0;
        let mut valid_count = 0usize;

        for step in 0..step_count {
            let time = results.specs.start + results.specs.save_step * (step as f64);

            // Compute signed loop score = product of signed link scores
            let mut loop_score = 1.0;
            let mut has_nan = false;

            for link in &links {
                // Find the link score offset
                let link_key = (link.from.clone(), link.to.clone());
                if let Some(&offset) = link_offsets
                    .iter()
                    .find(|((f, t), _)| *f == link_key.0 && *t == link_key.1)
                    .map(|(_, off)| off)
                {
                    let value = results.data[step * results.step_size + offset];
                    if value.is_nan() {
                        has_nan = true;
                        break;
                    }
                    loop_score *= value;
                } else {
                    // Link score variable not found - shouldn't happen
                    has_nan = true;
                    break;
                }
            }

            if has_nan {
                scores.push((time, f64::NAN));
            } else {
                scores.push((time, loop_score));
                abs_score_sum += loop_score.abs();
                valid_count += 1;
            }
        }

        let avg_abs_score = if valid_count > 0 {
            abs_score_sum / valid_count as f64
        } else {
            0.0
        };

        // Determine runtime polarity from scores
        let runtime_scores: Vec<f64> = scores.iter().map(|(_, s)| *s).collect();
        let polarity =
            LoopPolarity::from_runtime_scores(&runtime_scores).unwrap_or(polarity_structural);

        let loop_info = Loop {
            id: String::new(), // Will be assigned below
            links,
            stocks: loop_stocks,
            polarity,
        };

        found_loops.push(FoundLoop {
            loop_info,
            scores,
            avg_abs_score,
        });
    }

    // Sort by average |score| descending
    found_loops.sort_by(|a, b| {
        b.avg_abs_score
            .partial_cmp(&a.avg_abs_score)
            .unwrap_or(std::cmp::Ordering::Equal)
    });

    // Truncate to MAX_LOOPS
    found_loops.truncate(MAX_LOOPS);

    // Compute total score for filtering by relative contribution
    let total_avg_score: f64 = found_loops.iter().map(|l| l.avg_abs_score).sum();

    if total_avg_score > 0.0 {
        found_loops.retain(|l| l.avg_abs_score / total_avg_score >= MIN_CONTRIBUTION);
    }

    // Assign deterministic IDs
    assign_loop_ids(&mut found_loops);

    Ok(found_loops)
}

/// Assign deterministic IDs to discovered loops based on polarity and content.
fn assign_loop_ids(loops: &mut [FoundLoop]) {
    // Sort by a deterministic key for stable ID assignment
    loops.sort_by(|a, b| {
        let key_a = loop_sort_key(&a.loop_info);
        let key_b = loop_sort_key(&b.loop_info);
        key_a.cmp(&key_b)
    });

    let mut r_counter = 1;
    let mut b_counter = 1;
    let mut u_counter = 1;

    for found in loops.iter_mut() {
        found.loop_info.id = match found.loop_info.polarity {
            LoopPolarity::Reinforcing => {
                let id = format!("r{r_counter}");
                r_counter += 1;
                id
            }
            LoopPolarity::Balancing => {
                let id = format!("b{b_counter}");
                b_counter += 1;
                id
            }
            LoopPolarity::Undetermined => {
                let id = format!("u{u_counter}");
                u_counter += 1;
                id
            }
        };
    }
}

fn loop_sort_key(loop_info: &Loop) -> String {
    let mut vars: Vec<String> = loop_info
        .links
        .iter()
        .flat_map(|link| vec![link.from.as_str().to_string(), link.to.as_str().to_string()])
        .collect();
    vars.sort();
    vars.dedup();
    vars.join("_")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::common::canonicalize;

    /// Helper to build edges from tuples
    fn edges(tuples: &[(&str, &str, f64)]) -> Vec<(Ident<Canonical>, Ident<Canonical>, f64)> {
        tuples
            .iter()
            .map(|(from, to, score)| (canonicalize(from), canonicalize(to), *score))
            .collect()
    }

    /// Helper to build stock list from names
    fn stock_list(names: &[&str]) -> Vec<Ident<Canonical>> {
        names.iter().map(|n| canonicalize(n)).collect()
    }

    /// Helper to extract sorted node set from a path for comparison
    fn sorted_node_set(path: &[Ident<Canonical>]) -> Vec<String> {
        let mut set: Vec<String> = path.iter().map(|id| id.as_str().to_string()).collect();
        set.sort();
        set
    }

    // --- Test 1: SearchGraph construction ---

    #[test]
    fn test_search_graph_construction() {
        let graph = SearchGraph::from_edges(
            edges(&[
                ("a", "b", 10.0),
                ("a", "d", 100.0),
                ("b", "c", 10.0),
                ("c", "a", 10.0),
                ("d", "c", 0.1),
                ("d", "b", 100.0),
            ]),
            stock_list(&["a", "b", "c", "d"]),
        );

        // Verify adjacency list exists for all source nodes
        assert!(graph.adj.contains_key(&canonicalize("a")));
        assert!(graph.adj.contains_key(&canonicalize("b")));
        assert!(graph.adj.contains_key(&canonicalize("c")));
        assert!(graph.adj.contains_key(&canonicalize("d")));

        // Verify edges are sorted by |score| descending
        let a_edges = &graph.adj[&canonicalize("a")];
        assert_eq!(a_edges.len(), 2);
        assert_eq!(a_edges[0].to.as_str(), "d"); // score 100
        assert_eq!(a_edges[1].to.as_str(), "b"); // score 10

        let d_edges = &graph.adj[&canonicalize("d")];
        assert_eq!(d_edges.len(), 2);
        assert_eq!(d_edges[0].to.as_str(), "b"); // score 100
        assert_eq!(d_edges[1].to.as_str(), "c"); // score 0.1

        // Verify stocks
        assert_eq!(graph.stocks.len(), 4);
    }

    // --- Test 2: Trivial loop ---

    #[test]
    fn test_trivial_loop() {
        // Single stock with a flow forming one loop: stock -> flow -> stock
        let graph = SearchGraph::from_edges(
            edges(&[("stock", "flow", 1.0), ("flow", "stock", 1.0)]),
            stock_list(&["stock"]),
        );

        let loops = graph.find_strongest_loops();
        assert_eq!(loops.len(), 1, "Should find exactly one loop");

        let loop_nodes = sorted_node_set(&loops[0]);
        assert_eq!(loop_nodes, vec!["flow", "stock"]);
    }

    // --- Test 3: Figure 7 from the paper ---

    #[test]
    fn test_figure_7_paper() {
        // Edges from the paper's Figure 7:
        // a->b:10, a->d:100, b->c:10, c->a:10, d->c:0.1, d->b:100
        // All nodes are stocks for this test.
        let graph = SearchGraph::from_edges(
            edges(&[
                ("a", "b", 10.0),
                ("a", "d", 100.0),
                ("b", "c", 10.0),
                ("c", "a", 10.0),
                ("d", "c", 0.1),
                ("d", "b", 100.0),
            ]),
            stock_list(&["a", "b", "c", "d"]),
        );

        let loops = graph.find_strongest_loops();

        // The algorithm should find exactly one loop: [a, d, b, c]
        // (the strongest path). Other loops (a->b->c->a and a->d->c->a)
        // are pruned because the a->d->b path dominates and sets high
        // best_scores.
        assert_eq!(
            loops.len(),
            1,
            "Figure 7: should find exactly one loop (the strongest), found {}",
            loops.len()
        );

        let loop_nodes = sorted_node_set(&loops[0]);
        assert_eq!(
            loop_nodes,
            vec!["a", "b", "c", "d"],
            "Figure 7: the found loop should contain all four nodes"
        );
    }

    // --- Test 4: best_score persistence across stock iterations ---

    #[test]
    fn test_best_score_persistence() {
        // Create a graph where searching from stock A sets high best_scores
        // that should prevent stock B from finding anything.
        //
        // Graph:
        //   a -> x (score 1000)
        //   x -> a (score 1000)  -- loop through a
        //   b -> x (score 1)     -- weak path from b
        //   x -> b (score 1)     -- weak path back
        //
        // When searching from a (TARGET=a):
        //   check(a, 1.0) -> best_score[a]=1.0
        //     check(x, 1000) -> best_score[x]=1000
        //       check(a, 1M) -> a is visiting, a=TARGET, FOUND [a, x]
        //       check(b, 1000) -> best_score[b]=1000
        //         (b has no outbound edges in this test besides x, already visiting)
        //
        // When searching from b (TARGET=b):
        //   check(b, 1.0) -> 1.0 < best_score[b]=1000: PRUNED
        //
        // So only one loop should be found.
        let graph = SearchGraph::from_edges(
            edges(&[
                ("a", "x", 1000.0),
                ("x", "a", 1000.0),
                ("x", "b", 1.0),
                ("b", "x", 1.0),
            ]),
            stock_list(&["a", "b"]),
        );

        let loops = graph.find_strongest_loops();

        // Only the a-x loop should be found; b-x is pruned by best_score
        assert_eq!(
            loops.len(),
            1,
            "Should find only one loop due to best_score persistence"
        );

        let loop_nodes = sorted_node_set(&loops[0]);
        assert_eq!(loop_nodes, vec!["a", "x"]);
    }

    // --- Test 5: Loop deduplication ---

    #[test]
    fn test_loop_deduplication() {
        // Create a graph where the same loop could be found from two different
        // starting stocks if best_score didn't prevent it. With equally-scored
        // paths, the first stock finds the loop and sets best_scores that
        // WOULD prune the second stock. But let's test with a structure where
        // deduplication matters.
        //
        // Use equal scores so best_score allows re-exploration (0 is NOT < 0).
        // Actually with score=1 starting, after traversing edges with score=1,
        // the accumulated score stays 1.0 which equals the initial best_score
        // of 0... wait, initial best_score is 0, and 1.0 is NOT < 0, so it proceeds.
        //
        // Stock a and stock b both participate in the same loop: a -> b -> a
        let graph = SearchGraph::from_edges(
            edges(&[("a", "b", 1.0), ("b", "a", 1.0)]),
            stock_list(&["a", "b"]),
        );

        let loops = graph.find_strongest_loops();

        // Even though both stocks can reach the loop, deduplication should ensure
        // it appears only once
        assert_eq!(loops.len(), 1, "Same loop should appear only once");

        let loop_nodes = sorted_node_set(&loops[0]);
        assert_eq!(loop_nodes, vec!["a", "b"]);
    }

    // --- Test 6: Empty graph ---

    #[test]
    fn test_empty_graph() {
        let graph = SearchGraph::from_edges(vec![], stock_list(&[]));
        let loops = graph.find_strongest_loops();
        assert!(loops.is_empty(), "Empty graph should have no loops");
    }

    #[test]
    fn test_no_edges() {
        // Graph with stocks but no edges
        let graph = SearchGraph::from_edges(vec![], stock_list(&["a", "b"]));
        let loops = graph.find_strongest_loops();
        assert!(loops.is_empty(), "Graph with no edges should have no loops");
    }

    // --- Test 7: Zero-score edges ---

    #[test]
    fn test_zero_score_edges() {
        // A link with score 0 is still traversed (0 is NOT < 0, strict less-than),
        // but the accumulated score drops to 0 and won't improve beyond the
        // initial best_score of 0 at downstream nodes.
        let graph = SearchGraph::from_edges(
            edges(&[
                ("a", "b", 0.0), // zero-score link
                ("b", "a", 10.0),
            ]),
            stock_list(&["a"]),
        );

        let loops = graph.find_strongest_loops();

        // With score=0 on a->b, the accumulated score at b is 1.0*0=0.
        // best_score[b] starts at 0, and 0 is NOT < 0 (strict less-than),
        // so we DO proceed to explore from b.
        // From b: b->a with score 10, accumulated = 0*10 = 0.
        // a is visiting AND a=TARGET, so we FIND the loop.
        assert_eq!(
            loops.len(),
            1,
            "Zero-score edge should still allow traversal (strict less-than)"
        );
    }

    // --- Test 8: NaN handling ---

    #[test]
    fn test_nan_handling() {
        // NaN scores should be treated as 0
        let graph = SearchGraph::from_edges(
            edges(&[("a", "b", f64::NAN), ("b", "a", 10.0)]),
            stock_list(&["a"]),
        );

        let loops = graph.find_strongest_loops();

        // NaN is treated as 0, same behavior as zero-score test
        assert_eq!(
            loops.len(),
            1,
            "NaN should be treated as 0 (still traversable with strict less-than)"
        );
    }

    // --- Additional edge case tests ---

    #[test]
    fn test_self_loop_not_found() {
        // The algorithm requires visiting=true AND variable=TARGET.
        // A self-loop (a -> a) would have a in the visiting set when we
        // first visit it, but we'd need to return to a via an edge.
        // With a->a: check(a,1): visiting={a}, push a, edge a->a:
        //   check(a, score): a IS visiting AND a=TARGET -> found [a]
        let graph = SearchGraph::from_edges(edges(&[("a", "a", 5.0)]), stock_list(&["a"]));

        let loops = graph.find_strongest_loops();
        // Self-loops ARE found by this algorithm (single-node loops)
        assert_eq!(loops.len(), 1, "Self-loop should be found");
        assert_eq!(loops[0].len(), 1);
        assert_eq!(loops[0][0].as_str(), "a");
    }

    #[test]
    fn test_two_separate_loops() {
        // Two disconnected loops: a<->b and c<->d
        // With equal scores, both should be found since they're in separate
        // components and best_score from one doesn't affect the other.
        let graph = SearchGraph::from_edges(
            edges(&[
                ("a", "b", 1.0),
                ("b", "a", 1.0),
                ("c", "d", 1.0),
                ("d", "c", 1.0),
            ]),
            stock_list(&["a", "c"]),
        );

        let loops = graph.find_strongest_loops();
        assert_eq!(loops.len(), 2, "Should find two separate loops");
    }

    #[test]
    fn test_stocks_without_outbound_edges() {
        // A stock that has no outbound edges shouldn't cause errors
        let graph = SearchGraph::from_edges(
            edges(&[("a", "b", 1.0), ("b", "a", 1.0)]),
            stock_list(&["a", "c"]), // c has no edges
        );

        let loops = graph.find_strongest_loops();
        assert_eq!(loops.len(), 1, "Should find the a-b loop, c is harmless");
    }

    #[test]
    fn test_parse_link_offsets() {
        // Test the link offset parsing from variable names
        let mut offsets = HashMap::new();
        offsets.insert(
            Ident::<Canonical>::from_unchecked(
                canonicalize("$⁚ltm⁚link_score⁚population⁚births").to_source_repr(),
            ),
            0usize,
        );
        offsets.insert(
            Ident::<Canonical>::from_unchecked(
                canonicalize("$⁚ltm⁚link_score⁚births⁚population").to_source_repr(),
            ),
            1usize,
        );
        offsets.insert(
            Ident::<Canonical>::from_unchecked(canonicalize("population").to_source_repr()),
            2usize,
        );

        let results = Results {
            offsets,
            data: vec![0.0; 9].into_boxed_slice(),
            step_size: 3,
            step_count: 3,
            specs: crate::results::Specs {
                start: 0.0,
                stop: 2.0,
                dt: 1.0,
                save_step: 1.0,
                method: crate::results::Method::Euler,
                n_chunks: 3,
            },
            is_vensim: false,
        };

        let parsed = parse_link_offsets(&results);
        assert_eq!(parsed.len(), 2, "Should find 2 link score variables");

        // Verify the parsed entries
        let has_pop_to_births = parsed
            .iter()
            .any(|((f, t), _)| f.as_str() == "population" && t.as_str() == "births");
        let has_births_to_pop = parsed
            .iter()
            .any(|((f, t), _)| f.as_str() == "births" && t.as_str() == "population");

        assert!(has_pop_to_births, "Should parse population->births link");
        assert!(has_births_to_pop, "Should parse births->population link");
    }

    #[test]
    fn test_assign_loop_ids() {
        let mut loops = vec![
            FoundLoop {
                loop_info: Loop {
                    id: String::new(),
                    links: vec![
                        Link {
                            from: canonicalize("x"),
                            to: canonicalize("y"),
                            polarity: crate::ltm::LinkPolarity::Positive,
                        },
                        Link {
                            from: canonicalize("y"),
                            to: canonicalize("x"),
                            polarity: crate::ltm::LinkPolarity::Positive,
                        },
                    ],
                    stocks: vec![],
                    polarity: LoopPolarity::Reinforcing,
                },
                scores: vec![],
                avg_abs_score: 1.0,
            },
            FoundLoop {
                loop_info: Loop {
                    id: String::new(),
                    links: vec![
                        Link {
                            from: canonicalize("a"),
                            to: canonicalize("b"),
                            polarity: crate::ltm::LinkPolarity::Negative,
                        },
                        Link {
                            from: canonicalize("b"),
                            to: canonicalize("a"),
                            polarity: crate::ltm::LinkPolarity::Positive,
                        },
                    ],
                    stocks: vec![],
                    polarity: LoopPolarity::Balancing,
                },
                scores: vec![],
                avg_abs_score: 0.5,
            },
        ];

        assign_loop_ids(&mut loops);

        // After sorting by content key, a_b comes before x_y
        let a_b_loop = loops
            .iter()
            .find(|l| {
                l.loop_info
                    .links
                    .iter()
                    .any(|link| link.from.as_str() == "a")
            })
            .unwrap();
        let x_y_loop = loops
            .iter()
            .find(|l| {
                l.loop_info
                    .links
                    .iter()
                    .any(|link| link.from.as_str() == "x")
            })
            .unwrap();

        assert_eq!(a_b_loop.loop_info.id, "b1");
        assert_eq!(x_y_loop.loop_info.id, "r1");
    }
}
