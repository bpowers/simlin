// @generated by prost-build from project_io.proto
// DO NOT EDIT - regenerate with: pnpm build:gen-protobufs
//
// Proto file SHA256: 1ac337ad1e48df54d2b1e079c0b009883d9ad85c0bcd9c42c056e4af49d9a097
// prost-build version: 0.14

// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphicalFunction {
    #[prost(enumeration = "graphical_function::Kind", tag = "1")]
    pub kind: i32,
    #[prost(double, repeated, tag = "2")]
    pub x_points: ::prost::alloc::vec::Vec<f64>,
    #[prost(double, repeated, tag = "3")]
    pub y_points: ::prost::alloc::vec::Vec<f64>,
    #[prost(message, optional, tag = "4")]
    pub x_scale: ::core::option::Option<graphical_function::Scale>,
    #[prost(message, optional, tag = "5")]
    pub y_scale: ::core::option::Option<graphical_function::Scale>,
}
/// Nested message and enum types in `GraphicalFunction`.
pub mod graphical_function {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Scale {
        #[prost(double, tag = "1")]
        pub min: f64,
        #[prost(double, tag = "2")]
        pub max: f64,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Kind {
        Continuous = 0,
        Discrete = 1,
        Extrapolate = 2,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Continuous => "CONTINUOUS",
                Self::Discrete => "DISCRETE",
                Self::Extrapolate => "EXTRAPOLATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONTINUOUS" => Some(Self::Continuous),
                "DISCRETE" => Some(Self::Discrete),
                "EXTRAPOLATE" => Some(Self::Extrapolate),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Variable {
    #[prost(oneof = "variable::V", tags = "1, 2, 3, 4")]
    pub v: ::core::option::Option<variable::V>,
}
/// Nested message and enum types in `Variable`.
pub mod variable {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ScalarEquation {
        #[prost(string, tag = "1")]
        pub equation: ::prost::alloc::string::String,
        #[prost(string, optional, tag = "2")]
        pub initial_equation: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ApplyToAllEquation {
        #[prost(string, repeated, tag = "1")]
        pub dimension_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "2")]
        pub equation: ::prost::alloc::string::String,
        #[prost(string, optional, tag = "3")]
        pub initial_equation: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ArrayedEquation {
        #[prost(string, repeated, tag = "1")]
        pub dimension_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "2")]
        pub elements: ::prost::alloc::vec::Vec<arrayed_equation::Element>,
    }
    /// Nested message and enum types in `ArrayedEquation`.
    pub mod arrayed_equation {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Element {
            #[prost(string, tag = "1")]
            pub subscript: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub equation: ::prost::alloc::string::String,
            #[prost(string, optional, tag = "3")]
            pub initial_equation: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(message, optional, tag = "4")]
            pub gf: ::core::option::Option<super::super::GraphicalFunction>,
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Equation {
        #[prost(oneof = "equation::Equation", tags = "1, 2, 3")]
        pub equation: ::core::option::Option<equation::Equation>,
    }
    /// Nested message and enum types in `Equation`.
    pub mod equation {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Equation {
            #[prost(message, tag = "1")]
            Scalar(super::ScalarEquation),
            #[prost(message, tag = "2")]
            ApplyToAll(super::ApplyToAllEquation),
            #[prost(message, tag = "3")]
            Arrayed(super::ArrayedEquation),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Stock {
        #[prost(string, tag = "1")]
        pub ident: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "8")]
        pub equation: ::core::option::Option<Equation>,
        #[prost(string, tag = "3")]
        pub documentation: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub units: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "5")]
        pub inflows: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "6")]
        pub outflows: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(bool, tag = "7")]
        pub non_negative: bool,
        #[prost(bool, tag = "9")]
        pub can_be_module_input: bool,
        #[prost(enumeration = "Visibility", tag = "10")]
        pub visibility: i32,
        #[prost(int32, tag = "11")]
        pub uid: i32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Flow {
        #[prost(string, tag = "1")]
        pub ident: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "8")]
        pub equation: ::core::option::Option<Equation>,
        #[prost(string, tag = "3")]
        pub documentation: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub units: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "5")]
        pub gf: ::core::option::Option<super::GraphicalFunction>,
        #[prost(bool, tag = "7")]
        pub non_negative: bool,
        #[prost(bool, tag = "9")]
        pub can_be_module_input: bool,
        #[prost(enumeration = "Visibility", tag = "10")]
        pub visibility: i32,
        #[prost(int32, tag = "11")]
        pub uid: i32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Aux {
        #[prost(string, tag = "1")]
        pub ident: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "6")]
        pub equation: ::core::option::Option<Equation>,
        #[prost(string, tag = "3")]
        pub documentation: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub units: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "5")]
        pub gf: ::core::option::Option<super::GraphicalFunction>,
        #[prost(bool, tag = "7")]
        pub can_be_module_input: bool,
        #[prost(enumeration = "Visibility", tag = "8")]
        pub visibility: i32,
        #[prost(int32, tag = "9")]
        pub uid: i32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Module {
        #[prost(string, tag = "1")]
        pub ident: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub model_name: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub documentation: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub units: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "5")]
        pub references: ::prost::alloc::vec::Vec<module::Reference>,
        #[prost(bool, tag = "6")]
        pub can_be_module_input: bool,
        #[prost(enumeration = "Visibility", tag = "7")]
        pub visibility: i32,
        #[prost(int32, tag = "8")]
        pub uid: i32,
    }
    /// Nested message and enum types in `Module`.
    pub mod module {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Reference {
            #[prost(string, tag = "1")]
            pub src: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub dst: ::prost::alloc::string::String,
        }
    }
    /// access=output XMILE variables have public access, all others are private.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Visibility {
        Private = 0,
        Public = 1,
    }
    impl Visibility {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Private => "PRIVATE",
                Self::Public => "PUBLIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRIVATE" => Some(Self::Private),
                "PUBLIC" => Some(Self::Public),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum V {
        #[prost(message, tag = "1")]
        Stock(Stock),
        #[prost(message, tag = "2")]
        Flow(Flow),
        #[prost(message, tag = "3")]
        Aux(Aux),
        #[prost(message, tag = "4")]
        Module(Module),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewElement {
    #[prost(oneof = "view_element::Element", tags = "1, 2, 3, 4, 5, 6, 7, 8")]
    pub element: ::core::option::Option<view_element::Element>,
}
/// Nested message and enum types in `ViewElement`.
pub mod view_element {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Aux {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub uid: i32,
        #[prost(double, tag = "3")]
        pub x: f64,
        #[prost(double, tag = "4")]
        pub y: f64,
        #[prost(enumeration = "LabelSide", tag = "5")]
        pub label_side: i32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Stock {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub uid: i32,
        #[prost(double, tag = "3")]
        pub x: f64,
        #[prost(double, tag = "4")]
        pub y: f64,
        #[prost(enumeration = "LabelSide", tag = "5")]
        pub label_side: i32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FlowPoint {
        #[prost(double, tag = "1")]
        pub x: f64,
        #[prost(double, tag = "2")]
        pub y: f64,
        #[prost(int32, tag = "3")]
        pub attached_to_uid: i32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Flow {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub uid: i32,
        #[prost(double, tag = "3")]
        pub x: f64,
        #[prost(double, tag = "4")]
        pub y: f64,
        #[prost(enumeration = "LabelSide", tag = "5")]
        pub label_side: i32,
        /// int32 segmentWithAux = 3;
        /// double auxPercentageIntoSegment = 4;
        #[prost(message, repeated, tag = "6")]
        pub points: ::prost::alloc::vec::Vec<FlowPoint>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Link {
        #[prost(int32, tag = "1")]
        pub uid: i32,
        #[prost(int32, tag = "2")]
        pub from_uid: i32,
        #[prost(int32, tag = "3")]
        pub to_uid: i32,
        #[prost(enumeration = "link::Polarity", tag = "7")]
        pub polarity: i32,
        #[prost(oneof = "link::Shape", tags = "4, 5, 6")]
        pub shape: ::core::option::Option<link::Shape>,
    }
    /// Nested message and enum types in `Link`.
    pub mod link {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LinkPoints {
            #[prost(message, repeated, tag = "1")]
            pub points: ::prost::alloc::vec::Vec<super::FlowPoint>,
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Polarity {
            Unspecified = 0,
            Positive = 1,
            Negative = 2,
        }
        impl Polarity {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "POLARITY_UNSPECIFIED",
                    Self::Positive => "POLARITY_POSITIVE",
                    Self::Negative => "POLARITY_NEGATIVE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "POLARITY_UNSPECIFIED" => Some(Self::Unspecified),
                    "POLARITY_POSITIVE" => Some(Self::Positive),
                    "POLARITY_NEGATIVE" => Some(Self::Negative),
                    _ => None,
                }
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Shape {
            /// [0, 360)
            #[prost(double, tag = "4")]
            Arc(f64),
            #[prost(bool, tag = "5")]
            IsStraight(bool),
            #[prost(message, tag = "6")]
            MultiPoint(LinkPoints),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Module {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub uid: i32,
        #[prost(double, tag = "3")]
        pub x: f64,
        #[prost(double, tag = "4")]
        pub y: f64,
        #[prost(enumeration = "LabelSide", tag = "5")]
        pub label_side: i32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Alias {
        #[prost(int32, tag = "1")]
        pub uid: i32,
        #[prost(int32, tag = "2")]
        pub alias_of_uid: i32,
        #[prost(double, tag = "3")]
        pub x: f64,
        #[prost(double, tag = "4")]
        pub y: f64,
        #[prost(enumeration = "LabelSide", tag = "5")]
        pub label_side: i32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Cloud {
        #[prost(int32, tag = "1")]
        pub uid: i32,
        #[prost(int32, tag = "2")]
        pub flow_uid: i32,
        #[prost(double, tag = "3")]
        pub x: f64,
        #[prost(double, tag = "4")]
        pub y: f64,
    }
    /// Visual container for grouping related model elements.
    /// x/y are center coordinates (matching the internal convention).
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Group {
        #[prost(int32, tag = "1")]
        pub uid: i32,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(double, tag = "3")]
        pub x: f64,
        #[prost(double, tag = "4")]
        pub y: f64,
        #[prost(double, tag = "5")]
        pub width: f64,
        #[prost(double, tag = "6")]
        pub height: f64,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum LabelSide {
        Top = 0,
        Left = 1,
        Center = 2,
        Bottom = 3,
        Right = 4,
    }
    impl LabelSide {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Top => "TOP",
                Self::Left => "LEFT",
                Self::Center => "CENTER",
                Self::Bottom => "BOTTOM",
                Self::Right => "RIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TOP" => Some(Self::Top),
                "LEFT" => Some(Self::Left),
                "CENTER" => Some(Self::Center),
                "BOTTOM" => Some(Self::Bottom),
                "RIGHT" => Some(Self::Right),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Element {
        #[prost(message, tag = "1")]
        Aux(Aux),
        #[prost(message, tag = "2")]
        Stock(Stock),
        #[prost(message, tag = "3")]
        Flow(Flow),
        #[prost(message, tag = "4")]
        Link(Link),
        #[prost(message, tag = "5")]
        Module(Module),
        #[prost(message, tag = "6")]
        Alias(Alias),
        #[prost(message, tag = "7")]
        Cloud(Cloud),
        #[prost(message, tag = "8")]
        Group(Group),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Rect {
    #[prost(double, tag = "1")]
    pub x: f64,
    #[prost(double, tag = "2")]
    pub y: f64,
    #[prost(double, tag = "3")]
    pub width: f64,
    #[prost(double, tag = "4")]
    pub height: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct View {
    #[prost(enumeration = "view::ViewType", tag = "1")]
    pub kind: i32,
    /// background
    #[prost(message, repeated, tag = "3")]
    pub elements: ::prost::alloc::vec::Vec<ViewElement>,
    #[prost(message, optional, tag = "4")]
    pub view_box: ::core::option::Option<Rect>,
    #[prost(double, tag = "5")]
    pub zoom: f64,
    #[prost(bool, tag = "6")]
    pub use_lettered_polarity: bool,
}
/// Nested message and enum types in `View`.
pub mod view {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ViewType {
        /// INTERFACE = 1;
        /// POPUP = 2;
        /// VENDOR_SPECIFIC = 3;
        StockFlow = 0,
    }
    impl ViewType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::StockFlow => "STOCK_FLOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STOCK_FLOW" => Some(Self::StockFlow),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoopMetadata {
    #[prost(int32, repeated, tag = "1")]
    pub uids: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, tag = "2")]
    pub deleted: bool,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
}
/// Semantic/organizational group for categorizing model variables.
/// This is distinct from visual diagram groups (ViewElement.Group).
/// In Vensim, these are called "sectors".
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ModelGroup {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub doc: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub members: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "5")]
    pub run_enabled: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Model {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// namespaces
    /// no 'resource' or sim_specs in our normalized form
    #[prost(message, repeated, tag = "3")]
    pub variables: ::prost::alloc::vec::Vec<Variable>,
    #[prost(message, repeated, tag = "4")]
    pub views: ::prost::alloc::vec::Vec<View>,
    #[prost(message, repeated, tag = "5")]
    pub loop_metadata: ::prost::alloc::vec::Vec<LoopMetadata>,
    #[prost(message, repeated, tag = "6")]
    pub groups: ::prost::alloc::vec::Vec<ModelGroup>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Dt {
    #[prost(double, tag = "1")]
    pub value: f64,
    #[prost(bool, tag = "2")]
    pub is_reciprocal: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimSpecs {
    #[prost(double, tag = "1")]
    pub start: f64,
    #[prost(double, tag = "2")]
    pub stop: f64,
    #[prost(message, optional, tag = "3")]
    pub dt: ::core::option::Option<Dt>,
    #[prost(message, optional, tag = "4")]
    pub save_step: ::core::option::Option<Dt>,
    #[prost(enumeration = "SimMethod", tag = "5")]
    pub sim_method: i32,
    #[prost(string, optional, tag = "6")]
    pub time_units: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Dimension {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub obsolete_elements: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Vensim dimension mapping: when this dimension "maps to" another,
    /// elements of this dimension correspond positionally to elements of
    /// the target dimension. e.g., "DimA: A1, A2, A3 -> DimB" means
    /// A1<->B1, A2<->B2, A3<->B3. This is used when a variable indexed
    /// by DimB references variables indexed by DimA.
    #[prost(string, optional, tag = "5")]
    pub maps_to: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "dimension::Dimension", tags = "3, 4")]
    pub dimension: ::core::option::Option<dimension::Dimension>,
}
/// Nested message and enum types in `Dimension`.
pub mod dimension {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DimensionElements {
        #[prost(string, repeated, tag = "1")]
        pub elements: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DimensionSize {
        #[prost(uint32, tag = "1")]
        pub size: u32,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Dimension {
        #[prost(message, tag = "3")]
        Elements(DimensionElements),
        #[prost(message, tag = "4")]
        Size(DimensionSize),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Unit {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub equation: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub disabled: bool,
    #[prost(string, repeated, tag = "4")]
    pub alias: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// often we want to import or export a project to a string; whether it is
/// an XMILE model, Vensim, or something else.  This is very useful for
/// debugging import problems, and can be used to send both the protobuf and
/// XMILE output from the frontend to the filesystem
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Source {
    #[prost(enumeration = "source::Extension", tag = "1")]
    pub extension: i32,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Source`.
pub mod source {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Extension {
        Unspecified = 0,
        Xmile = 1,
        Vensim = 2,
    }
    impl Extension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Xmile => "XMILE",
                Self::Vensim => "VENSIM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "XMILE" => Some(Self::Xmile),
                "VENSIM" => Some(Self::Vensim),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectPatch {
    #[prost(message, repeated, tag = "1")]
    pub project_ops: ::prost::alloc::vec::Vec<ProjectOperation>,
    #[prost(message, repeated, tag = "2")]
    pub models: ::prost::alloc::vec::Vec<ModelPatch>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelPatch {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub ops: ::prost::alloc::vec::Vec<ModelOperation>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectOperation {
    #[prost(oneof = "project_operation::Op", tags = "1, 2")]
    pub op: ::core::option::Option<project_operation::Op>,
}
/// Nested message and enum types in `ProjectOperation`.
pub mod project_operation {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Op {
        #[prost(message, tag = "1")]
        SetSimSpecs(super::SetSimSpecsOp),
        #[prost(message, tag = "2")]
        SetSource(super::SetSourceOp),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelOperation {
    #[prost(oneof = "model_operation::Op", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9")]
    pub op: ::core::option::Option<model_operation::Op>,
}
/// Nested message and enum types in `ModelOperation`.
pub mod model_operation {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Op {
        #[prost(message, tag = "1")]
        UpsertStock(super::UpsertStockOp),
        #[prost(message, tag = "2")]
        UpsertFlow(super::UpsertFlowOp),
        #[prost(message, tag = "3")]
        UpsertAux(super::UpsertAuxOp),
        #[prost(message, tag = "4")]
        UpsertModule(super::UpsertModuleOp),
        #[prost(message, tag = "5")]
        DeleteVariable(super::DeleteVariableOp),
        #[prost(message, tag = "6")]
        RenameVariable(super::RenameVariableOp),
        #[prost(message, tag = "7")]
        UpsertView(super::UpsertViewOp),
        #[prost(message, tag = "8")]
        DeleteView(super::DeleteViewOp),
        #[prost(message, tag = "9")]
        UpdateStockFlows(super::UpdateStockFlowsOp),
    }
}
/// Updates only the inflows/outflows of an existing stock, preserving all other fields.
/// Use this when connecting/disconnecting flows from stocks in the UI.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateStockFlowsOp {
    #[prost(string, tag = "1")]
    pub ident: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub inflows: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub outflows: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSimSpecsOp {
    #[prost(message, optional, tag = "1")]
    pub sim_specs: ::core::option::Option<SimSpecs>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertStockOp {
    #[prost(message, optional, tag = "1")]
    pub stock: ::core::option::Option<variable::Stock>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertFlowOp {
    #[prost(message, optional, tag = "1")]
    pub flow: ::core::option::Option<variable::Flow>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertAuxOp {
    #[prost(message, optional, tag = "1")]
    pub aux: ::core::option::Option<variable::Aux>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertModuleOp {
    #[prost(message, optional, tag = "1")]
    pub module: ::core::option::Option<variable::Module>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteVariableOp {
    #[prost(string, tag = "1")]
    pub ident: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RenameVariableOp {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub to: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertViewOp {
    #[prost(uint32, tag = "1")]
    pub index: u32,
    #[prost(message, optional, tag = "2")]
    pub view: ::core::option::Option<View>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteViewOp {
    #[prost(uint32, tag = "1")]
    pub index: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetSourceOp {
    #[prost(message, optional, tag = "1")]
    pub source: ::core::option::Option<Source>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Project {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub sim_specs: ::core::option::Option<SimSpecs>,
    #[prost(message, repeated, tag = "4")]
    pub dimensions: ::prost::alloc::vec::Vec<Dimension>,
    #[prost(message, repeated, tag = "6")]
    pub units: ::prost::alloc::vec::Vec<Unit>,
    #[prost(message, repeated, tag = "3")]
    pub models: ::prost::alloc::vec::Vec<Model>,
    #[prost(message, optional, tag = "5")]
    pub source: ::core::option::Option<Source>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SimMethod {
    Euler = 0,
    RungeKutta4 = 1,
    RungeKutta2 = 3,
}
impl SimMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Euler => "EULER",
            Self::RungeKutta4 => "RUNGE_KUTTA_4",
            Self::RungeKutta2 => "RUNGE_KUTTA_2",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EULER" => Some(Self::Euler),
            "RUNGE_KUTTA_4" => Some(Self::RungeKutta4),
            "RUNGE_KUTTA_2" => Some(Self::RungeKutta2),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BuiltinId {
    Unspecified = 0,
    Abs = 1,
    Arccos = 2,
    Arcsin = 3,
    Arctan = 4,
    Cos = 5,
    Exp = 6,
    Inf = 7,
    Int = 8,
    Ln = 9,
    Log10 = 10,
    Max = 11,
    Min = 12,
    Pi = 13,
    Pulse = 14,
    Ramp = 15,
    SafeDiv = 16,
    Sin = 17,
    Sqrt = 18,
    Step = 19,
    Tan = 20,
    Sign = 21,
}
impl BuiltinId {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UNSPECIFIED",
            Self::Abs => "Abs",
            Self::Arccos => "Arccos",
            Self::Arcsin => "Arcsin",
            Self::Arctan => "Arctan",
            Self::Cos => "Cos",
            Self::Exp => "Exp",
            Self::Inf => "Inf",
            Self::Int => "Int",
            Self::Ln => "Ln",
            Self::Log10 => "Log10",
            Self::Max => "Max",
            Self::Min => "Min",
            Self::Pi => "Pi",
            Self::Pulse => "Pulse",
            Self::Ramp => "Ramp",
            Self::SafeDiv => "SafeDiv",
            Self::Sin => "Sin",
            Self::Sqrt => "Sqrt",
            Self::Step => "Step",
            Self::Tan => "Tan",
            Self::Sign => "Sign",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED" => Some(Self::Unspecified),
            "Abs" => Some(Self::Abs),
            "Arccos" => Some(Self::Arccos),
            "Arcsin" => Some(Self::Arcsin),
            "Arctan" => Some(Self::Arctan),
            "Cos" => Some(Self::Cos),
            "Exp" => Some(Self::Exp),
            "Inf" => Some(Self::Inf),
            "Int" => Some(Self::Int),
            "Ln" => Some(Self::Ln),
            "Log10" => Some(Self::Log10),
            "Max" => Some(Self::Max),
            "Min" => Some(Self::Min),
            "Pi" => Some(Self::Pi),
            "Pulse" => Some(Self::Pulse),
            "Ramp" => Some(Self::Ramp),
            "SafeDiv" => Some(Self::SafeDiv),
            "Sin" => Some(Self::Sin),
            "Sqrt" => Some(Self::Sqrt),
            "Step" => Some(Self::Step),
            "Tan" => Some(Self::Tan),
            "Sign" => Some(Self::Sign),
            _ => None,
        }
    }
}
